from typing import List, Dict
from vectorstores.faiss_manager import FAISSManager
from langchain.chains import RetrievalQA
from langchain_community.llms import VertexAI

class DocumentProcessor:
    def __init__(self):
        # 初始化LLM和嵌入模型
        self.llm = VertexAI(model_name="gemini-pro")
        self.faiss_manager = FAISSManager(self._get_embedding_func())

    def _get_embedding_func(self):
        """返回嵌入函数（与您的模型对接）"""
        def embed_func(texts: List[str]) -> List[List[float]]:
            # 调用您的实际模型
            return self.model.get_embeddings(texts)  # 替换为真实调用
        return embed_func

    def generate_fr_document(self, file_paths: List[str], project_info: Dict = None) -> Dict:
        """生成需求文档（集成FAISS检索）"""
        # 1. 加载文档
        documents = self.load_documents(file_paths)
        if not documents:
            raise ValueError("无可处理文档")

        # 2. 创建FAISS向量库和检索器
        self.faiss_manager.create_from_texts(documents)
        qa_chain = self._create_qa_chain()

        # 3. 构建提示词
        prompt = self._build_prompt(project_info, documents[:3])

        # 4. 执行生成
        result = qa_chain.invoke({"query": prompt})

        # 5. 解析结果
        return self._parse_result(result)

    def _create_qa_chain(self) -> RetrievalQA:
        """创建检索增强生成链"""
        return RetrievalQA.from_chain_type(
            llm=self.llm,
            chain_type="stuff",
            retriever=self.faiss_manager.create_retriever(
                search_kwargs={"k": 3, "score_threshold": 0.7}
            ),
            return_source_documents=True
        )

    def _build_prompt(self, project_info: Dict, context_docs: List[str]) -> str:
        """构建结构化提示词"""
        context_str = "\n".join(f"- {doc[:200]}..." for doc in context_docs)
        return f"""
        Generate a technical requirements document in markdown format:

        # {project_info.get('name', 'Untitled Project')}
        **Description**: {project_info.get('description', '')}

        ## Core Requirements
        {self._format_features(project_info.get('features', []))}

        ## Technical Specifications
        Include code samples where applicable.

        Reference Context:
        {context_str}
        """

    def _format_features(self, features: List[str]) -> str:
        return "\n".join(f"- {feat}" for feat in features)

    def _parse_result(self, result: Dict) -> Dict:
        """解析生成结果"""
        return {
            "content": result["result"],
            "sources": [doc.page_content for doc in result["source_documents"]]
        }